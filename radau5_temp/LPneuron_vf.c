/*  Vector field function and events for Radau integrator.
  This code was automatically generated by PyDSTool, but may be modified by hand. */

#include <math.h>
#include <Python.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "events.h"
#include "maxmin.h"
#include "signum.h"
#include "vfield.h"

extern double *gICs;
extern double **gBds;
extern double globalt0;

static double pi = 3.1415926535897931;

double signum(double x)
{
  if (x<0) {
    return -1;
  }
  else if (x==0) {
    return 0;
  }
  else if (x>0) {
    return 1;
  }
  else {
    /* must be that x is Not-a-Number */
    return x;
  }
}


/* Variable, aux variable, parameter, and input definitions: */ 
#define Cm	p_[0]
#define ECa	p_[1]
#define EK	p_[2]
#define ENa	p_[3]
#define Eh	p_[4]
#define El	p_[5]
#define Iext	p_[6]
#define ciCa	p_[7]
#define gAf	p_[8]
#define gAs	p_[9]
#define gCa1	p_[10]
#define gCa2	p_[11]
#define gK	p_[12]
#define gKCa	p_[13]
#define gNa	p_[14]
#define gh	p_[15]
#define gl	p_[16]
#define kAf	p_[17]
#define kAs	p_[18]
#define kCa	p_[19]
#define kKCa	p_[20]
#define kh	p_[21]
#define kr	p_[22]
#define skr	p_[23]
#define sr	p_[24]
#define vA	p_[25]
#define vb	p_[26]
#define vkr	p_[27]
#define vr	p_[28]
#define Ca	Y_[0]
#define aA	Y_[1]
#define aCa1	Y_[2]
#define aCa2	Y_[3]
#define aKCa	Y_[4]
#define ah	Y_[5]
#define bAf	Y_[6]
#define bAs	Y_[7]
#define bCa1	Y_[8]
#define bKCa	Y_[9]
#define h	Y_[10]
#define n	Y_[11]
#define v	Y_[12]


double __maxof2(double e1_, double e2_, double *p_, double *wk_, double *xv_);
double __maxof3(double e1_, double e2_, double e3_, double *p_, double *wk_, double *xv_);
double __maxof4(double e1_, double e2_, double e3_, double e4_, double *p_, double *wk_, double *xv_);
double __minof2(double e1_, double e2_, double *p_, double *wk_, double *xv_);
double __minof3(double e1_, double e2_, double e3_, double *p_, double *wk_, double *xv_);
double __minof4(double e1_, double e2_, double e3_, double e4_, double *p_, double *wk_, double *xv_);
double __rhs_if(int cond_, double e1_, double e2_, double *p_, double *wk_, double *xv_);
double getbound(char *name, int which_bd, double *p_, double *wk_, double *xv_);
double globalindepvar(double t, double *p_, double *wk_, double *xv_);
double initcond(char *varname, double *p_, double *wk_, double *xv_);
double minf(double __v__, double *p_, double *wk_, double *xv_);
int getindex(char *name, double *p_, double *wk_, double *xv_);
int heav(double x_, double *p_, double *wk_, double *xv_);

int N_EVENTS = 0;
void assignEvents(EvFunType *events){
 
}

void auxvars(unsigned, unsigned, double, double*, double*, double*, unsigned, double*, unsigned, double*);
void jacobian(unsigned, unsigned, double, double*, double*, double**, unsigned, double*, unsigned, double*);
void jacobianParam(unsigned, unsigned, double, double*, double*, double**, unsigned, double*, unsigned, double*);
int N_AUXVARS = 0;


int N_EXTINPUTS = 0;


void vfieldfunc(unsigned n_, unsigned np_, double t, double *Y_, double *p_, double *f_, unsigned wkn_, double *wk_, unsigned xvn_, double *xv_){

f_[0] = -1*ciCa*(gCa1*aCa1*bCa1+gCa2*aCa2)*(v-ECa)+kCa*(0.05-Ca);
f_[1] = 140.*(1./(1+exp(-1*(v-vA)/16.))-aA);
f_[2] = 50./(1+exp(-1*(v+11.)/7.))-50.*aCa1;
f_[3] = 10./(1+exp(-1*(v-22.)/7.))-10.*aCa2;
f_[4] = kKCa*Ca/((1+exp(-1*(0.0434783*v+0.026087*Ca+0.869565)))*(1+exp(-1*(0.166667*v+0.1*Ca+3.83333)))*(2.5+Ca))-kKCa*aKCa;
f_[5] = kr*(1+exp((v-vkr)/skr))*(1./(1+exp((v-vr)/sr))-ah);
f_[6] = kAf*(1./(1+exp((v-vb)/6.))-bAf);
f_[7] = kAs*(1./(1+exp((v-vb)/6.))-bAs);
f_[8] = 16./(1+exp(0.125*(v+50.)))-16.*bCa1;
f_[9] = 21./(0.6+Ca)-35.*bKCa;
f_[10] = kh*(0.08*(1-h)*exp(-0.125*(v+39.))-h/(1+exp(-1*(0.2*v+8.))));
f_[11] = (282./(1+exp(-1*(v+25.)/17.))-282.*n)/(1+exp(-1*(v-10.)/22.));
f_[12] = (Iext+(gNa*pow(minf(v, p_, wk_, xv_),3)*h*(ENa-v)+(gCa1*aCa1*bCa1+gCa2*aCa2)*(ECa-v)+gK*pow(n,4)*(EK-v)+gKCa*aKCa*bKCa*(EK-v)+(gAf*bAf+gAs*bAs)*pow(aA,3)*(EK-v)+gh*ah*(Eh-v)+gl*(El-v)))/Cm;

}




double __maxof2(double e1_, double e2_, double *p_, double *wk_, double *xv_) {
if (e1_ > e2_) {return e1_;} else {return e2_;};
}


double __maxof3(double e1_, double e2_, double e3_, double *p_, double *wk_, double *xv_) {
double temp_;
if (e1_ > e2_) {temp_ = e1_;} else {temp_ = e2_;};
if (e3_ > temp_) {return e3_;} else {return temp_;};
}


double __maxof4(double e1_, double e2_, double e3_, double e4_, double *p_, double *wk_, double *xv_) {
double temp_;
if (e1_ > e2_) {temp_ = e1_;} else {temp_ = e2_;};
if (e3_ > temp_) {temp_ = e3_;};
if (e4_ > temp_) {return e4_;} else {return temp_;};
}


double __minof2(double e1_, double e2_, double *p_, double *wk_, double *xv_) {
if (e1_ < e2_) {return e1_;} else {return e2_;};
}


double __minof3(double e1_, double e2_, double e3_, double *p_, double *wk_, double *xv_) {
double temp_;
if (e1_ < e2_) {temp_ = e1_;} else {temp_ = e2_;};
if (e3_ < temp_) {return e3_;} else {return temp_;};
}


double __minof4(double e1_, double e2_, double e3_, double e4_, double *p_, double *wk_, double *xv_) {
double temp_;
if (e1_ < e2_) {temp_ = e1_;} else {temp_ = e2_;};
if (e3_ < temp_) {temp_ = e3_;};
if (e4_ < temp_) {return e4_;} else {return temp_;};
}


double __rhs_if(int cond_, double e1_, double e2_, double *p_, double *wk_, double *xv_) {
  if (cond_) {return e1_;} else {return e2_;};
}


double getbound(char *name, int which_bd, double *p_, double *wk_, double *xv_) {
  return gBds[which_bd][getindex(name, p_, wk_, xv_)];
}


double globalindepvar(double t, double *p_, double *wk_, double *xv_) {
  return globalt0+t;
}


double initcond(char *varname, double *p_, double *wk_, double *xv_) {

  if (strcmp(varname, "Ca")==0)
	return gICs[0];
  else if (strcmp(varname, "aA")==0)
	return gICs[1];
  else if (strcmp(varname, "aCa1")==0)
	return gICs[2];
  else if (strcmp(varname, "aCa2")==0)
	return gICs[3];
  else if (strcmp(varname, "aKCa")==0)
	return gICs[4];
  else if (strcmp(varname, "ah")==0)
	return gICs[5];
  else if (strcmp(varname, "bAf")==0)
	return gICs[6];
  else if (strcmp(varname, "bAs")==0)
	return gICs[7];
  else if (strcmp(varname, "bCa1")==0)
	return gICs[8];
  else if (strcmp(varname, "bKCa")==0)
	return gICs[9];
  else if (strcmp(varname, "h")==0)
	return gICs[10];
  else if (strcmp(varname, "n")==0)
	return gICs[11];
  else if (strcmp(varname, "v")==0)
	return gICs[12];
  else {
	fprintf(stderr, "Invalid variable name %s for initcond call\n", varname);
	return 0.0/0.0;
	}
}


double minf(double __v__, double *p_, double *wk_, double *xv_) {


return 1/(1+15*exp(-1*((__v__+34)/13))*(1-exp(-0.05*(__v__+6)))/(0.11*__v__+0.66));

}


int getindex(char *name, double *p_, double *wk_, double *xv_) {

  if (strcmp(name, "Ca")==0)
	return 0;
  else if (strcmp(name, "aA")==0)
	return 1;
  else if (strcmp(name, "aCa1")==0)
	return 2;
  else if (strcmp(name, "aCa2")==0)
	return 3;
  else if (strcmp(name, "aKCa")==0)
	return 4;
  else if (strcmp(name, "ah")==0)
	return 5;
  else if (strcmp(name, "bAf")==0)
	return 6;
  else if (strcmp(name, "bAs")==0)
	return 7;
  else if (strcmp(name, "bCa1")==0)
	return 8;
  else if (strcmp(name, "bKCa")==0)
	return 9;
  else if (strcmp(name, "h")==0)
	return 10;
  else if (strcmp(name, "n")==0)
	return 11;
  else if (strcmp(name, "v")==0)
	return 12;
  else if (strcmp(name, "Cm")==0)
	return 13;
  else if (strcmp(name, "ECa")==0)
	return 14;
  else if (strcmp(name, "EK")==0)
	return 15;
  else if (strcmp(name, "ENa")==0)
	return 16;
  else if (strcmp(name, "Eh")==0)
	return 17;
  else if (strcmp(name, "El")==0)
	return 18;
  else if (strcmp(name, "Iext")==0)
	return 19;
  else if (strcmp(name, "ciCa")==0)
	return 20;
  else if (strcmp(name, "gAf")==0)
	return 21;
  else if (strcmp(name, "gAs")==0)
	return 22;
  else if (strcmp(name, "gCa1")==0)
	return 23;
  else if (strcmp(name, "gCa2")==0)
	return 24;
  else if (strcmp(name, "gK")==0)
	return 25;
  else if (strcmp(name, "gKCa")==0)
	return 26;
  else if (strcmp(name, "gNa")==0)
	return 27;
  else if (strcmp(name, "gh")==0)
	return 28;
  else if (strcmp(name, "gl")==0)
	return 29;
  else if (strcmp(name, "kAf")==0)
	return 30;
  else if (strcmp(name, "kAs")==0)
	return 31;
  else if (strcmp(name, "kCa")==0)
	return 32;
  else if (strcmp(name, "kKCa")==0)
	return 33;
  else if (strcmp(name, "kh")==0)
	return 34;
  else if (strcmp(name, "kr")==0)
	return 35;
  else if (strcmp(name, "skr")==0)
	return 36;
  else if (strcmp(name, "sr")==0)
	return 37;
  else if (strcmp(name, "vA")==0)
	return 38;
  else if (strcmp(name, "vb")==0)
	return 39;
  else if (strcmp(name, "vkr")==0)
	return 40;
  else if (strcmp(name, "vr")==0)
	return 41;
  else {
	fprintf(stderr, "Invalid name %s for getindex call\n", name);
	return 0.0/0.0;
	}
}


int heav(double x_, double *p_, double *wk_, double *xv_) {
  if (x_>0.0) {return 1;} else {return 0;}
}

void auxvars(unsigned n_, unsigned np_, double t, double *Y_, double *p_, double *f_, unsigned wkn_, double *wk_, unsigned xvn_, double *xv_){


}


void massMatrix(unsigned n_, unsigned np_, double t, double *Y_, double *p_, double **f_, unsigned wkn_, double *wk_, unsigned xvn_, double *xv_) {
}

void jacobian(unsigned n_, unsigned np_, double t, double *Y_, double *p_, double **f_, unsigned wkn_, double *wk_, unsigned xvn_, double *xv_) {
}

void jacobianParam(unsigned n_, unsigned np_, double t, double *Y_, double *p_, double **f_, unsigned wkn_, double *wk_, unsigned xvn_, double *xv_) {
}
